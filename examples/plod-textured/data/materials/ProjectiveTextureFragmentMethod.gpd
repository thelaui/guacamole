{
  "name" : "ProjectiveTextureFragmentMethod",
  "source" : "
    layout (std430, binding=2) uniform projective_texure_block {
      mat4  projection_view_mats[50];
      vec4  frustum_positions[50];
      uvec2 projection_textures[50];
      int   frustum_count;
    };

    int get_id_smallest_distance(in vec4 position) {
      float minimal_distance = 99999.9;
      int result = 0;
      for (int i = 0; i < frustum_count; ++i) {
        float distance = length(position - frustum_positions[i]);
        if (distance < minimal_distance) {
          minimal_distance = distance;
          result = i;
        }
      }

      return result;
    }

    int get_id_closest_valid_projection(in vec4 position) {
      float minimal_distance = 99999.9;
      int result = 0;
      for (int i = 0; i < frustum_count; ++i) {
        if (projection_textures[i] != uvec2(0)) {
          float distance = length(position - frustum_positions[i]);
          if (distance < minimal_distance) {
            vec4 proj_tex_space_pos = projection_view_mats[i] * position;

            float depth = proj_tex_space_pos.z;
            // perspective division
            proj_tex_space_pos /= proj_tex_space_pos.w;

            if (abs(proj_tex_space_pos.x) <  1.0 &&
                abs(proj_tex_space_pos.y) <  1.0 &&
                depth                     >= 0.0) {

              minimal_distance = distance;
              result = i;
            }
          }
        }
      }

      return result;
    }

    vec3 get_projected_color(int frustum_id) {
      vec3 result = vec3(0.0);

      // check if texture is loaded
      if (projection_textures[frustum_id] != uvec2(0)) {

        // project fragment position into the projective texture
        vec4 proj_tex_space_pos = projection_view_mats[frustum_id] * vec4(gua_world_position, 1.0);

        float depth = proj_tex_space_pos.z;
        // perspective division
        proj_tex_space_pos /= proj_tex_space_pos.w;

        // check if fragment is visible by frustum
        if (abs(proj_tex_space_pos.x) <  1.0 &&
            abs(proj_tex_space_pos.y) <  1.0 &&
            depth                     >= 0.0) {

          vec2 proj_texcoord = proj_tex_space_pos.xy;
          proj_texcoord = 0.5 * proj_texcoord + 0.5;
          result = texture(sampler2D(projection_textures[frustum_id]), proj_texcoord.xy).rgb;
        }
      }

      return result;
    }

    vec3 sample_color_average(int frustum_id, int range) {
      vec3 result = vec3(0.0);

      const int min_pos = max(frustum_id - range, 0);
      const int max_pos = min(frustum_id + range, frustum_count - 1);
      float real_range = 0.0;

      for (int pos = min_pos; pos <= max_pos; ++pos) {
        vec3 color = get_projected_color(pos);
        if (color != vec3(0.0)) {
          result += color;
          real_range += 1.0;
        }

      }

      if (real_range != 0.0) {
       result /= real_range;
      }

      return result;
    }

    vec3 sample_color_median(int frustum_id, int range) {
      vec3 result = vec3(0.0);

      vec3 average_color = sample_color_average(frustum_id, range);
      float current_min_distance = 2.0;

      const int min_pos = max(frustum_id - range, 0);
      const int max_pos = min(frustum_id + range, frustum_count - 1);

      for (int pos = min_pos; pos <= max_pos; ++pos) {
        vec3 color = get_projected_color(pos);
        float distance_to_average = length(color - average_color);
        if (distance_to_average < current_min_distance) {
          result = color;
          current_min_distance = distance_to_average;
        }

      }

      return result;
    }

    void ProjectiveTextureFragmentMethod() {

      int frustum_id = 0;

      if (selection_mode == 0) {
        frustum_id = get_id_smallest_distance(gua_camera_position_4);
      } else if (selection_mode == 1) {
        frustum_id = get_id_closest_valid_projection(vec4(gua_world_position, 1.0));
      }

      vec3 sampled_color = vec3(0.0);

      if (blending_mode == 0) {
        sampled_color = sample_color_average(frustum_id, blending_range);
      } else if (blending_mode == 1) {
        sampled_color = sample_color_median(frustum_id, blending_range);
      }

      if (sampled_color != vec3(0.0)) {
        gua_color = mix(gua_color, sampled_color, blending_factor);
      }

      gua_roughness = 1.0;
      gua_metalness = 1.0;
      gua_emissivity = 1.0;
      gua_flags_passthrough = true;
      gua_alpha = 1.0;
    }
  ",
  "uniforms" :
  [
    {
      "name" : "blending_range",
      "type" : "int",
      "value": "0"
    },
    {
      "name" : "blending_mode",
      "type" : "int",
      "value": "0"
    },
    {
      "name" : "selection_mode",
      "type" : "int",
      "value": "0"
    },
    {
      "name" : "blending_factor",
      "type" : "float",
      "value": "1.0"
    }
  ]
}
