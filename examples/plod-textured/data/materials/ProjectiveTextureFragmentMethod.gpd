{
  "name" : "ProjectiveTextureFragmentMethod",
  "source" : "
    layout (std430, binding=2) uniform projective_texure_block {
      mat4  projection_view_mats[100];
      uvec2 projection_textures[100];
      int   frustum_count;
    };

    vec3 get_projected_color(int frustum_id) {
      vec3 result = vec3(0.0);

      // project fragment position into the projective texture
      vec4 proj_tex_space_pos = projection_view_mats[frustum_id] * vec4(gua_world_position, 1.0);

      float depth = proj_tex_space_pos.z;
      // perspective division
      proj_tex_space_pos /= proj_tex_space_pos.w;
      if (abs(proj_tex_space_pos.x) <  1.0 &&
          abs(proj_tex_space_pos.y) <  1.0 &&
          depth                     >= 0.0) {

        vec2 proj_texcoord = proj_tex_space_pos.xy;
        proj_texcoord = 0.5 * proj_texcoord + 0.5;
        result = texture(sampler2D(projection_textures[frustum_id]), proj_texcoord.xy).rgb;
      }

      return result;
    }

    vec3 sample_color_average(int frustum_id, int range) {
      vec3 result = vec3(0.0);

      const int min_pos = max(frustum_id - range, 0);
      const int max_pos = min(frustum_id + range, frustum_count - 1);
      float real_range = 0.0;

      for (int pos = min_pos; pos <= max_pos; ++pos) {
        vec3 color = get_projected_color(pos);
        if (color != vec3(0.0)) {
          result += color;
          real_range += 1.0;
        }

      }

      return result / real_range;
    }

    vec3 sample_color_median(int frustum_id, int range) {
      vec3 result = vec3(0.0);

      vec3 average_color = sample_color_average(frustum_id, range);
      float current_min_distance = 2.0;

      const int min_pos = max(frustum_id - range, 0);
      const int max_pos = min(frustum_id + range, frustum_count - 1);

      for (int pos = min_pos; pos <= max_pos; ++pos) {
        vec3 color = get_projected_color(pos);
        float distance_to_average = length(color - average_color);
        if (distance_to_average < current_min_distance) {
          result = color;
          current_min_distance = distance_to_average;
        }

      }

      return result;
    }

    void ProjectiveTextureFragmentMethod() {

      int frustum_id = max(0, min(current_frustum, frustum_count - 1));

      if (blending_mode == 0) {
        gua_color = sample_color_average(frustum_id, blending_range);
      } else if (blending_mode == 1) {
        gua_color = sample_color_median(frustum_id, blending_range);
      }
      gua_roughness = 1.0;
      gua_metalness = 1.0;
      gua_emissivity = 1.0;
      gua_flags_passthrough = false;
      gua_alpha = 1.0;
    }
  ",
  "uniforms" :
  [
    {
      "name" : "current_frustum",
      "type" : "int",
      "value": "0"
    },
    {
      "name" : "blending_range",
      "type" : "int",
      "value": "0"
    },
    {
      "name" : "blending_mode",
      "type" : "int",
      "value": "0"
    }
  ]
}
